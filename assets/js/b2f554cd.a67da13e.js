"use strict";(self.webpackChunkericdudley=self.webpackChunkericdudley||[]).push([[5894],{6042:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"calculator-interpreter","metadata":{"permalink":"/blog/calculator-interpreter","source":"@site/blog/2023-09-03-basic-calculator.mdx","title":"Implementing a calculator interpreter","description":"Today, I\'ll be covering how to implement a calculator interpreter (i.e. evaluating 1 + 2 * 3 as 7). First we\'ll cover the overall concept, and then we\'ll dive into the details of how to implement it.","date":"2023-09-03T00:00:00.000Z","formattedDate":"September 3, 2023","tags":[{"label":"software development","permalink":"/blog/tags/software-development"},{"label":"mathematics","permalink":"/blog/tags/mathematics"},{"label":"puzzles","permalink":"/blog/tags/puzzles"},{"label":"leetcode","permalink":"/blog/tags/leetcode"}],"readingTime":12.11,"hasTruncateMarker":true,"authors":[{"name":"Eric Dudley","title":"Software Engineer","url":"https://www.linkedin.com/in/eric-dudley-894721106","imageURL":"https://github.com/ericdudley.png","key":"me"}],"frontMatter":{"slug":"calculator-interpreter","title":"Implementing a calculator interpreter","authors":"me","tags":["software development","mathematics","puzzles","leetcode"]},"nextItem":{"title":"Visualizing The 100 Prisoners Problem","permalink":"/blog/100-prisoners-problem"}},"content":"Today, I\'ll be covering how to implement a calculator interpreter (i.e. evaluating `1 + 2 * 3` as `7`). First we\'ll cover the overall concept, and then we\'ll dive into the details of how to implement it.\\n\\n> #### This post has interactive components demonstrating the concepts, make sure to try them out by modifying the expressions in the input boxes with the mouse pointer icons!\\n\\n\x3c!--truncate--\x3e\\n\\nimport Collapse from \\"@site/src/components/Collapse\\";\\n\\n## Problem Statement\\n\\n> Given a string `s` representing a valid expression, implement a calculator interpreter to evaluate it, and return the result of the evaluation.\\n\\n> **Example 1:**\\n>\\n> ```\\n> Input: s = \\"1 + 1\\"\\n> Output: 2\\n> ```\\n\\n> **Example 2:**\\n>\\n> ```\\n> Input: s = \\" 2 - 1 + 2 \\"\\n> Output: 3\\n> ```\\n\\n> **Example 3:**\\n>\\n> ```\\n> Input: s = \\"1 + 2 * 3\\"\\n> Output: 7\\n> ```\\n\\n> **Example 4:**\\n>\\n> ```\\n> Input: s = \\"(1 + 2 * 3) * 2\\"\\n> Output: 14\\n> ```\\n\\nThe provided expression can contain the following:\\n\\n- Addition `+`\\n- Subtraction `-`\\n- Multiplication `*`\\n- Division `/`\\n- Negation `-` (unary)\\n- Parentheses `(` and `)`\\n- Whitespace ` `\\n- Integers `0-MAX_INT`\\n\\n## How should I approach the solution?\\n\\nOne way to approach this problem is to utilize a stack (or set of stacks) to keep track of the current state of the expression. We can then iterate through the expression, and push/pop values from the stack as we encounter them. This approach is fairly simple, but it can be difficult to debug and extend.\\n\\nAnother approach is to use a more formalized approach composed of three modules commonly used in [computer language parsing](https://en.wikipedia.org/wiki/Parsing).\\n\\n### Language Parsing\\n\\nWe will break the problem down into three sub-problems:\\n\\n| Sub-Problem        | Module      | Description                                      |\\n| ------------------ | ----------- | ------------------------------------------------ |\\n| Lexical Analysis   | Lexer       | Convert the input string into a list of tokens.  |\\n| Syntactic Analysis | Parser      | Converts the list of tokens into a syntax tree.  |\\n| Evaluation         | Interpreter | Evaluate the syntax tree, and return the result. |\\n\\n<Collapse title=\\"What are tokens and syntax trees?\\">\\n\\nWhat is a token?\\n\\n> A token is the smallest element of a program that is meaningful in syntactic analysis. In the case of a calculator, a token can be a number, an operation, or a parenthesis. Notice that a token is not necessarily a single character, it can be a sequence of characters, like a number composed of multiple digits.\\n\\nWhat is a syntax tree?\\n\\n> A syntax tree is a representation of the tokens (although not every token must be represented in the tree) that captures the meaning of the expression. This tree encodes the relationship of symbols in the expression such that the interpreter can correctly evaluate the result of the expression. In the case of a calculator, the syntax tree will be a tree, where each node is an operation, and each leaf node is a number.\\n\\n</Collapse>\\n\\nApplied to this problem:\\n\\n```mermaid\\ngraph LR\\nA[1 + 12] --\x3e B[Lexer]\\nB --\x3e C[\\"[1, +, 12]\\"]\\nC --\x3e D[Parser]\\n\\nsubgraph Syntax Tree\\nE[\\"+\\"]\\nE --\x3e F[\\"1\\"]\\nE --\x3e G[\\"12\\"]\\nend\\n\\nD --\x3e E\\nE --\x3e H[Interpreter]\\nH --\x3e I[13]\\n\\n```\\n\\nBy breaking the problem down into these sub-problems, we can implement and test in a more iterative fashion before assembling the final solution.\\n\\n## How do I implement the solution?\\n\\nLet\'s get coding! We\'ll start with the lexer.\\n\\n### Lexer\\n\\nimport { useMemo, useState } from \\"react\\";\\n\\nimport LexerView from \\"../src/components/basic-calculator/LexerView\\";\\nimport TextInput from \\"../src/components/basic-calculator/TextInput\\";\\nimport { useBasicCalculatorStore } from \\"../src/components/basic-calculator/utils\\";\\n\\nThe lexer for this problem is fairly simple. For each character in our input string, we will do the following:\\n\\n- If a valid operation character, add as a token.\\n- If a digit, concatenate the digits until the next non-digit character, and add as a token.\\n- All other characters (invalid operations or whitespace) will be ignored.\\n\\nWe will report an error if the input string contains any characters outside of the valid character set.\\n\\n<Collapse title=\\"View code\\">\\n\\n[View in GitHub](https://github.com/ericdudley/ericdudley/blob/main/src/utils/basic-calculator/lexer.ts)\\n\\n```ts\\nexport class Lexer {\\n  inputText: string;\\n  tokens: string[];\\n  idx: number;\\n\\n  constructor(inputText: string) {\\n    this.inputText = inputText;\\n    this.idx = 0;\\n    this.tokens = [];\\n\\n    let i = 0;\\n    let currNum = \\"\\";\\n\\n    while (i < inputText.length) {\\n      while (DIGITS.has(inputText[i])) {\\n        currNum += inputText[i];\\n        i += 1;\\n      }\\n\\n      if (currNum.length > 0) {\\n        this.tokens.push(currNum);\\n        currNum = \\"\\";\\n      }\\n\\n      if (OPERATIONS.has(inputText[i])) {\\n        this.tokens.push(inputText[i]);\\n      }\\n\\n      i += 1;\\n    }\\n  }\\n\\n  getNextToken() {\\n    if (this.idx === this.tokens.length) {\\n      return null;\\n    } else {\\n      const token = this.tokens[this.idx];\\n      this.idx += 1;\\n      return token;\\n    }\\n  }\\n\\n  peekNextToken() {\\n    if (this.idx === this.tokens.length) {\\n      return null;\\n    } else {\\n      const token = this.tokens[this.idx];\\n      return token;\\n    }\\n  }\\n\\n  hasNextToken() {\\n    return this.idx < this.tokens.length;\\n  }\\n\\n  isValid() {\\n    return Array.from(this.inputText).every(\\n      (c) => DIGITS.has(c) || OPERATIONS.has(c) || c === \\" \\"\\n    );\\n  }\\n}\\n```\\n\\n</Collapse>\\n\\nTry adding some input text below, to see how the lexer will tokenize it.\\n\\n<TextInput />\\n<LexerView />\\n\\nAwesome, now that our lexer is producing tokens, we can feed these tokens into the next module, the parser.\\n\\n### Parser\\n\\nimport ParserView from \\"../src/components/basic-calculator/ParserView\\";\\n\\nThe parser is the most complicated part of this problem, we need to convert the list of tokens into a syntax tree. The syntax tree is a representation of the input string, where each node is an operation, and each leaf node is a number.\\n\\n- If the node is a binary operation (+, -, \\\\*, /), it will have two children, the left and right operands.\\n- If the node is a unary operation (-, ()), it will have one child, the operand, stored in the right child.\\n- If the node is a number, it will store a value and have no children. This is a leaf node.\\n\\n<Collapse title=\\"Learn more about how the parser works\\">\\n\\n#### Understanding the Parser\\n\\nThis parser is classified as a **Recursive Descent Parser**, a top-down parsing method.\\n\\n##### Core Concepts\\n\\n1. **Grammar**:\\n   - `expression` represents operations like addition (`+`) or subtraction (`-`). An expression can be composed of one or more `terms` separated by addition or subtraction.\\n   - `term` concerns itself with multiplication (`*`) or division (`/`). A term can be composed of one or more `factors` separated by multiplication or division.\\n   - `factor` A factor can be a constant (like `1` or `2`), or an expression (like `1 + 2` or `(1 + 2) * 3`).\\n\\n##### Enforcing Order of Operations:\\n\\nThe recursive structure of this parser enables it to intuitively enforce the order of operations.\\n\\n**Expression -> Term -> Factor**: At the highest level, when parsing an `expression`, the parser looks for `terms`, and within each term, it searches for `factors`. This hierarchical descent ensures that the foundational mathematical operations (those within parentheses or just standalone numbers) are processed first (`factors`), followed by multiplication and division (`terms`), and finally addition and subtraction (`expression`).\\n\\n**An example**: Consider the input `3 + 4 * 2`.\\n\\n1. **Initialization**: The parser starts at the `expression` level.\\n\\n2. **Finding the First Term**:\\n\\n   - At the `expression` level, it seeks its first `term`.\\n   - Within the `term`, it looks for its first `factor`.\\n   - At the `factor` level, it identifies `3`.\\n   - `3` is then returned upwards as the first `term` to the `expression` level.\\n\\n3. **Recognizing the Addition Operation**:\\n\\n   - The `expression` level spots the next token as an addition (`+`).\\n   - Consequently, an addition node is initialized. The parser now needs another `term` to complete this addition operation.\\n\\n4. **Identifying the Next Term**:\\n\\n   - Diving back to the `term` level, the parser identifies the next `factor` as `4`.\\n\\n5. **Spotting the Multiplication Operation**:\\n\\n   - Remaining within the `term` level, the parser identifies the subsequent token as multiplication (`*`).\\n   - It then establishes a multiplication node, asking for another `factor` to complete this multiplication.\\n\\n6. **Completing the Multiplication**:\\n\\n   - Descending once more to the `factor` level, it discovers `2` as the next `factor`.\\n   - `2` is sent upward, completing the multiplication node.\\n\\n7. **Wrapping it up**:\\n   - This multiplication node, representing `4 * 2`, is then passed up to the `expression` level.\\n   - It serves as the second `term` for our initially established addition node.\\n   - With no more tokens left, the `expression` level concludes the parsing, and the final result is the addition node that encompasses the entire expression: `3 + (4 * 2)`.\\n\\n```mermaid\\n\\ngraph LR\\nsubgraph Syntax Tree\\nE[\\"+\\"]\\nE --\x3e F[\\"3\\"]\\nE --\x3e G[\\"*\\"]\\nG --\x3e H[\\"4\\"]\\nG --\x3e I[\\"2\\"]\\nend\\n\\n```\\n\\ntldr; The parser will always process the deepest nested (highest-precedence) operations first, and then work its way back up.\\n\\n##### Error Handling\\n\\n1. **Errors**: Any deviations from expected constructs will result in an error message; however, the parser will always try to complete the parse and return a tree. For example, if there are missing parentheses at the end of an expression `3 * (1 + 2`, the parser will still return the correct result, but will also return an error message.\\n\\n</Collapse>\\n\\n<Collapse title=\\"View code\\">\\n\\n[View in GitHub](https://github.com/ericdudley/ericdudley/blob/main/src/utils/basic-calculator/parser.ts)\\n\\n```ts\\nimport { v4 as uuid } from \\"uuid\\";\\nimport { OPERATIONS } from \\"./constants\\";\\nimport { Lexer } from \\"./lexer\\";\\nimport { Node, NullableNode } from \\"./node\\";\\n\\n/**\\n * expression - addition or subtraction\\n * term - multiplication or division\\n * factor - constant or parantheses\\n */\\nexport class Parser {\\n  lexer: Lexer;\\n  error?: string;\\n\\n  constructor(lexer: Lexer) {\\n    this.lexer = lexer;\\n  }\\n\\n  parse(): { result?: NullableNode; error?: string } {\\n    try {\\n      const result = this.getExpression();\\n\\n      if (this.lexer.hasNextToken()) {\\n        return {\\n          result,\\n          error: \\"Completed parsing, but did not read all tokens.\\",\\n        };\\n      }\\n      return { result, error: this.error };\\n    } catch (error) {\\n      if (error) {\\n        return {\\n          error: error.message ?? \\"Unknown error\\",\\n        };\\n      }\\n    }\\n  }\\n\\n  getExpression(): NullableNode {\\n    let node = this.getTerm();\\n\\n    while (\\n      node &&\\n      (this.lexer.peekNextToken() === \\"+\\" || this.lexer.peekNextToken() === \\"-\\")\\n    ) {\\n      const token = this.lexer.getNextToken();\\n\\n      node = new Node({\\n        type: token === \\"+\\" ? \\"add\\" : \\"sub\\",\\n        left: node,\\n        right: this.getTerm(),\\n      });\\n    }\\n\\n    return node;\\n  }\\n\\n  getTerm(): NullableNode {\\n    let node = this.getFactor();\\n\\n    while (\\n      node &&\\n      (this.lexer.peekNextToken() === \\"*\\" || this.lexer.peekNextToken() === \\"/\\")\\n    ) {\\n      const token = this.lexer.getNextToken();\\n\\n      node = new Node({\\n        type: token === \\"*\\" ? \\"mul\\" : \\"div\\",\\n        left: node,\\n        right: this.getFactor(),\\n      });\\n    }\\n\\n    return node;\\n  }\\n\\n  getFactor(): NullableNode {\\n    const token = this.lexer.getNextToken();\\n\\n    if (token == null) {\\n      return null;\\n    } else if (token === \\"(\\") {\\n      const node = new Node({\\n        type: \\"par\\",\\n        right: this.getExpression(),\\n      });\\n\\n      if (this.lexer.peekNextToken() === \\")\\") {\\n        this.lexer.getNextToken();\\n      } else {\\n        this.error = \\"Missing close parentheses\\";\\n      }\\n\\n      return node;\\n    } else if (OPERATIONS.has(token)) {\\n      return null;\\n    } else {\\n      return new Node({\\n        type: \\"val\\",\\n        val: Number(token),\\n      });\\n    }\\n  }\\n\\n  getTreeViewData(): { treeData?: TreeData; error?: string } {\\n    const parsed = this.parse();\\n\\n    function getTree(node: NullableNode): TreeData {\\n      if (!node) {\\n        return null;\\n      }\\n\\n      if (node.type === \\"val\\") {\\n        return {\\n          name: String(node.val),\\n          key: uuid(),\\n        };\\n      }\\n\\n      if (node.type === \\"add\\") {\\n        return {\\n          name: \\"+\\",\\n          key: uuid(),\\n          children: [node.left, node.right]\\n            .map((child) => getTree(child))\\n            .filter((child) => !!child),\\n        };\\n      }\\n\\n      if (node.type === \\"sub\\") {\\n        return {\\n          name: \\"-\\",\\n          key: uuid(),\\n          children: [node.left, node.right]\\n            .map((child) => getTree(child))\\n            .filter((child) => !!child),\\n        };\\n      }\\n\\n      if (node.type === \\"mul\\") {\\n        return {\\n          name: \\"*\\",\\n          key: uuid(),\\n          children: [node.left, node.right]\\n            .map((child) => getTree(child))\\n            .filter((child) => !!child),\\n        };\\n      }\\n\\n      if (node.type === \\"div\\") {\\n        return {\\n          name: \\"/\\",\\n          key: uuid(),\\n          children: [node.left, node.right]\\n            .map((child) => getTree(child))\\n            .filter((child) => !!child),\\n        };\\n      }\\n\\n      if (node.type === \\"neg\\") {\\n        return {\\n          name: \\"-1 *\\",\\n          key: uuid(),\\n          children: [node.right]\\n            .map((child) => getTree(child))\\n            .filter((child) => !!child),\\n        };\\n      }\\n\\n      if (node.type === \\"par\\") {\\n        return {\\n          name: \\"()\\",\\n          key: uuid(),\\n          children: [node.right]\\n            .map((child) => getTree(child))\\n            .filter((child) => !!child),\\n        };\\n      }\\n    }\\n\\n    return { treeData: getTree(parsed.result), error: parsed.error };\\n  }\\n}\\n```\\n\\n</Collapse>\\n\\n<TextInput />\\n<ParserView />\\n\\n### Interpreter\\n\\nimport InterpreterView from \\"../src/components/basic-calculator/InterpreterView\\";\\n\\nSince our parser returns our tokens as a syntax tree with meaningful structure, we can now evaluate the expression by recursively traversing the tree and applying the operations from the leaves up to the root.\\n\\n1. Base case: If the node is a number, return the value.\\n2. Recursive case:\\n   - If the node is a unary operation, evaluate the right child, and apply the operation to the resulting value.\\n   - If the node is a binary operation, evaluate the left and right children, and apply the operation to the resulting values.\\n\\n<Collapse title=\\"View code\\">\\n\\n[View in GitHub](https://github.com/ericdudley/ericdudley/blob/main/src/utils/basic-calculator/interpreter.ts)\\n\\n```ts\\nimport { Parser } from \\"./parser\\";\\nimport { NullableNode } from \\"./node\\";\\nimport { formatNumber } from \\"./constants\\";\\n\\nexport class Interpreter {\\n  parser: Parser;\\n  error?: string;\\n\\n  constructor(parser: Parser) {\\n    this.parser = parser;\\n  }\\n\\n  _interpret(root: NullableNode, steps: string[]): number {\\n    if (!root) {\\n      return 0;\\n    }\\n\\n    let val: number;\\n    let step: string;\\n\\n    switch (root.type) {\\n      case \\"val\\": {\\n        val = root.val;\\n        break;\\n      }\\n      case \\"neg\\": {\\n        const right = this._interpret(root.right, steps);\\n        val = -1 * right;\\n        step = `-1 * ${formatNumber(right)}`;\\n        break;\\n      }\\n      case \\"add\\": {\\n        const left = this._interpret(root.left, steps);\\n        const right = this._interpret(root.right, steps);\\n        val = left + right;\\n        step = `${formatNumber(left)} + ${formatNumber(right)}`;\\n        break;\\n      }\\n      case \\"sub\\": {\\n        const left = this._interpret(root.left, steps);\\n        const right = this._interpret(root.right, steps);\\n        val = left - right;\\n        step = `${formatNumber(left)} - ${formatNumber(right)}`;\\n        break;\\n      }\\n      case \\"par\\": {\\n        const right = this._interpret(root.right, steps);\\n        val = right;\\n        break;\\n      }\\n      case \\"mul\\": {\\n        const left = this._interpret(root.left, steps);\\n        const right = this._interpret(root.right, steps);\\n        val = left * right;\\n        step = `${formatNumber(left)} * ${formatNumber(right)}`;\\n        break;\\n      }\\n      case \\"div\\": {\\n        const left = this._interpret(root.left, steps);\\n        const right = this._interpret(root.right, steps);\\n        val = left / right;\\n        step = `${formatNumber(left)} / ${formatNumber(right)}`;\\n        break;\\n      }\\n      default:\\n        this.error = `Unknown node type: ${root.type}`;\\n    }\\n\\n    if (step) {\\n      steps.push(`${step} = ${formatNumber(val)}`);\\n    }\\n    return val;\\n  }\\n\\n  interpret(): { steps: string[]; value: number; error?: string } {\\n    this.error = \\"\\";\\n    const steps = [];\\n    const { result } = this.parser.parse();\\n    const value = this._interpret(result, steps);\\n    return {\\n      value,\\n      steps,\\n      error: this.error,\\n    };\\n  }\\n}\\n```\\n\\n</Collapse>\\n\\n<TextInput />\\n<InterpreterView />\\n\\n## Conclusion\\n\\nIn this post, we\'ve implemented a calculator interpreter, along the way, touching upon the principles of language parsing. By dividing our main task into three distinct modules \u2014 lexer, parser, and interpreter \u2014 we were able to break down the problem into smaller, more manageable pieces. This approach allowed us to test each module individually, and then assemble the final solution. I hope you enjoyed this post, and learned something new!"},{"id":"100-prisoners-problem","metadata":{"permalink":"/blog/100-prisoners-problem","source":"@site/blog/2023-05-08-100-prisoners.md","title":"Visualizing The 100 Prisoners Problem","description":"Who doesn\'t love a good puzzle? They challenge us, intrigue us, and sometimes even frustrate us. But most importantly, they provide a unique opportunity to test our problem-solving skills and stretch our minds. Today, we\'re going to delve into an intriguing logic problem known as the 100 Prisoners Problem.","date":"2023-05-08T00:00:00.000Z","formattedDate":"May 8, 2023","tags":[{"label":"simulation","permalink":"/blog/tags/simulation"},{"label":"software development","permalink":"/blog/tags/software-development"},{"label":"mathematics","permalink":"/blog/tags/mathematics"},{"label":"puzzles","permalink":"/blog/tags/puzzles"}],"readingTime":8.015,"hasTruncateMarker":true,"authors":[{"name":"Eric Dudley","title":"Software Engineer","url":"https://www.linkedin.com/in/eric-dudley-894721106","imageURL":"https://github.com/ericdudley.png","key":"me"}],"frontMatter":{"slug":"100-prisoners-problem","title":"Visualizing The 100 Prisoners Problem","authors":"me","tags":["simulation","software development","mathematics","puzzles"]},"prevItem":{"title":"Implementing a calculator interpreter","permalink":"/blog/calculator-interpreter"},"nextItem":{"title":"Code Review Mindset","permalink":"/blog/code-review-mindset"}},"content":"Who doesn\'t love a good puzzle? They challenge us, intrigue us, and sometimes even frustrate us. But most importantly, they provide a unique opportunity to test our problem-solving skills and stretch our minds. Today, we\'re going to delve into an intriguing logic problem known as the [100 Prisoners Problem](https://en.wikipedia.org/wiki/100_prisoners_problem).\\n\\n\x3c!--truncate--\x3e\\n\\nEventually we\'ll come to a surprising result that seems to go against the odds, but first let\'s set the stage by presenting the problem.\\n\\n## Unraveling the 100 Prisoners Problem\\n\\nImagine 100 prisoners, each assigned a unique number from 1 to 100. Their freedom is at stake in a peculiar game, the rules of which are quite simple but the strategy anything but.\\n\\nIn the warden\'s room, there are 100 drawers and 100 pieces of paper with the numbers from 1 to 100 written on them in a random order. The warden places these pieces of paper in the drawers, one per drawer, and closes the drawers.\\n\\nThe prisoners are allowed to strategize before the game starts; once they are ready, the game begins. Each prisoner, one at a time, is led into the room and allowed to open 50 drawers of their choosing. If they locate their own number, they quietly exit the warden\'s room into a holding cell, and the drawers are returned to their undisturbed state before the next prisoner enters.\\n\\nIf all prisoners find their number, they are all set free. If even one fails, they all are returned to their cells.\\n\\nNow that you\'ve been introduced to the problem, have a moment to ponder. What strategy would you employ if you were one of these prisoners?\\n\\n## Simulation\\n\\nA visual representation can help solidify one\'s understanding of a problem, so I created the following simulation. Try it out and see if you can figure out the optimal strategy, and then continue reading to see if you were right.\\n\\n:::info\\nMake sure to increase the simulation tick to slow down the simulation to see what the optimal strategy is doing. The \'Group by cycle\' and \'Color by cycle\' checkboxes will also help you visualize what the strategy is.\\n:::\\n\\n### Give it a try here:\\n\\n<iframe src=\\"https://ericdudley.github.io/100prisoners/\\" style={{ width: \\"100%\\", height: \\"600px\\", border: \\"none\\" }}></iframe>\\n\\n## The Strategies\\n\\nNow, let\'s dive deeper into the strategies our prisoners can use.\\n\\n### The Random Strategy\\n\\nPerhaps the most intuitive approach for the prisoners would be to adopt a random strategy. Each prisoner could simply open 50 drawers at random, hoping to find their number among them. At first glance, this approach seems reasonable. After all, with 50 attempts, each prisoner has a 50% chance of finding their number, right?\\n\\nUnfortunately, the reality is not quite so rosy. While the probability that a single prisoner finds their number using the random strategy is indeed 50%, the situation changes dramatically when we consider all the prisoners together.\\n\\nRemember, the prisoners will only be freed if _all_ of them find their numbers. So what we\'re really interested in is not the probability of one prisoner finding their number, but the probability of all 100 prisoners doing so. To calculate this, we need to multiply the individual probabilities together.\\n\\nMathematically, this looks like:\\n\\n`(1/2) * (1/2) * ... * (1/2) = (1/2)^100`\\n\\nWhen you calculate this out, the result is approximately 0.0000000000000000000000000000008, a number so close to zero that it\'s practically negligible. In layman\'s terms, the odds of all the prisoners finding their numbers using the random strategy are, for all intents and purposes, zero.\\n\\nThis situation is akin to asking the prisoners to flip 100 coins and freeing them only if all the coins land on heads. While it\'s certainly possible for a single coin to land on heads, the likelihood of all 100 coins doing so is astronomically small. It\'s a vivid demonstration of the fact that probabilities can be deceptive when compounded on a large scale.\\n\\nThus, while the random strategy may seem appealing due to its simplicity, it\'s a gamble that the prisoners are unlikely to win. So what strategy should they use instead?\\n\\n### The Optimal Strategy\\n\\nIn the face of such bleak odds, you may think that the prisoners are doomed to failure. However, a remarkable strategy exists that provides the prisoners with a survival probability of over 30%. This strategy hinges on the crucial observation that the prisoners don\'t have to decide beforehand which drawers to open. Instead, they can use the information they gain from the contents of each opened drawer to inform their next choice. This dynamism is the key to the optimal strategy.\\n\\nHere\'s how it works:\\n\\n1. Each prisoner begins by opening the drawer labeled with their ownf number.\\n2. If the drawer contains their own number, they\'ve succeeded and can exit the warden\'s room.\\n3. If the drawer contains the number of another prisoner, they then open the drawer labeled with this newly found number.\\n4. The prisoner repeats steps 2 and 3 until they either find their own number or fail because their number is not found in the first fifty opened drawers.\\n\\nThis strategy might seem like it\'s overly dependent on chance, but there\'s a method to the madness. The crucial point is that by starting with their own number, each prisoner guarantees they are on the unique permutation cycle of drawers containing their number. The question then becomes whether this cycle is longer than fifty drawers.\\n\\nThe concept of a \\"permutation cycle\\" might sound complex, but it\'s a straightforward concept. In our context, a permutation cycle refers to the sequence of numbers that a prisoner encounters when they follow the strategy outlined above. For instance, if prisoner 1 opens a drawer containing the number 20, then opens the drawer labeled 20 to find the number 35, and so on, the permutation cycle is the sequence of numbers (1, 20, 35, ...). The length of this cycle is the number of steps it takes for the sequence to return to the starting number\u2014in this case, 1. Since the prisoner starts with the drawer labelled with their own number, the length of the cycle is the number of drawers they must open before they find their own number. If there is a cycle of length greater than fifty, the prisoners will fail; otherwise, they will succeed.\\n\\nThe beauty of this strategy lies in its blend of determinism and adaptability. Each prisoner starts with a deterministic choice, the drawer labeled with their own number, but then adapts their subsequent choices based on the numbers they encounter. It transforms the probability of success into a simple question, \\"What is the probability that there is a permutation cycle of length greater than fifty?\\" Turns out, this probability is about 70%, meaning the prisoners have a about a 30% chance of success.\\n\\n:::info Fun fact\\nif you know the prisoners are following this strategy, given any drawer configuration, you could determine whether the prisoners will succeed or fail before the game even begins.\\n:::\\n\\n## A JavaScript Detour: `Promise.resolve()` vs `setTimeout(() => {}, 0)`\\n\\nWhen developing an interactive simulation like this, it\'s crucial to ensure the simulation doesn\'t block the browser\'s main thread. If we\'re not careful, an intensive computation could freeze up the browser and render it unresponsive. To prevent this, we can use JavaScript\'s built-in asynchronous mechanisms to break up the simulation into manageable chunks.\\n\\nOriginally, I used `setTimeout(runSimulationTick, simulationTickMs)` to achieve this. `setTimeout` not only allows us to divide the computation into smaller pieces, but it also gives us control over the simulation speed by adjusting the `simulationTickMs` value. This means we can slow down or speed up the simulation as desired.\\n\\nNow, you might think that setting `simulationTickMs` to 0 would make the simulation run as fast as possible. While it certainly speeds things up, there\'s an even faster method: `Promise.resolve(1).then(runSimulationTick)`. However, there\'s a catch: this approach doesn\'t allow for speed control and, if overused, can block the main thread, leading to a browser crash.\\n\\nTo strike the right balance, I fine-tuned the simulation loop:\\n\\n1. If `simulationTickMs` is greater than 0, we use `setTimeout(runSimulationTick, simulationTickMs)`.\\n2. If `simulationTickMs` is 0, we primarily use `Promise.resolve(1).then(runSimulationTick)`, but intersperse `setTimeout(runSimulationTick, 0)` every 1 in X ticks. X is a number I fine-tuned for maximum speed that wouldn\'t crash the browser.\\n\\nBut what makes these two methods so different?\\n\\nThe distinction lies in the JavaScript event loop. `setTimeout` schedules a macrotask, while `Promise.resolve` schedules a microtask. The key difference is that the event loop executes macrotasks after all microtasks have completed. Furthermore, the browser prioritizes microtasks over rendering the page. This means that excessive use of `Promise.resolve` in a recursive function can monopolize the browser\'s resources, preventing it from rendering the page and potentially leading to a crash.\\n\\nHowever, by alternating `Promise.resolve` with `setTimeout`, we ensure the browser has regular opportunities to render the page, preventing crashes and maintaining a responsive user interface.\\n\\n## Conclusion\\n\\nIn our journey through the 100 Prisoners Problem, we\'ve grappled with probability, tested our strategic thinking, and even delved into some simulation implementation details. The optimal strategy, with its inherent cycle-based approach, offers an interesting exploration into the heart of problem-solving. It\'s a testament to the power of logic, even in seemingly impossible situations. Conversely, the random strategy serves as a reminder that sometimes, chance can play a surprising role in determining outcomes.\\n\\nRemember, the power of logic, strategy, and even a bit of luck can together open the door to solutions in the most challenging scenarios.\\n\\nWant to dive deeper? Feel free to explore the [source code](https://github.com/ericdudley/100prisoners) of the simulation. The simulation itself is hosted on GitHub Pages [here](https://ericdudley.github.io/100prisoners/)."},{"id":"code-review-mindset","metadata":{"permalink":"/blog/code-review-mindset","source":"@site/blog/2023-04-21-code-reviews.md","title":"Code Review Mindset","description":"tldr; Focus on adopting a healthy code review mindset, rather than specific tips, to build a culture of knowledge sharing and improve code quality.","date":"2023-04-21T00:00:00.000Z","formattedDate":"April 21, 2023","tags":[{"label":"code review","permalink":"/blog/tags/code-review"},{"label":"best practices","permalink":"/blog/tags/best-practices"},{"label":"software engineering","permalink":"/blog/tags/software-engineering"},{"label":"software development","permalink":"/blog/tags/software-development"}],"readingTime":14.04,"hasTruncateMarker":true,"authors":[{"name":"Eric Dudley","title":"Software Engineer","url":"https://www.linkedin.com/in/eric-dudley-894721106","imageURL":"https://github.com/ericdudley.png","key":"me"}],"frontMatter":{"slug":"code-review-mindset","title":"Code Review Mindset","authors":"me","tags":["code review","best practices","software engineering","software development"]},"prevItem":{"title":"Visualizing The 100 Prisoners Problem","permalink":"/blog/100-prisoners-problem"},"nextItem":{"title":"First Blog Post","permalink":"/blog/first-blog-post"}},"content":"tldr; Focus on adopting a healthy code review mindset, rather than specific tips, to build a culture of knowledge sharing and improve code quality.\\n\\nAs a software engineer, I\'ve participated in countless code reviews, both as a reviewer and a PR author. I\'ve seen the good, the bad, and the ugly when it comes to the code review process. In this blog post, I\'ll share my insights on the importance of a healthy code review mindset and how you can adopt it to make your code reviews more effective, efficient, and enjoyable.\\n\\n\x3c!--truncate--\x3e\\n\\n<h1 className=\\"!mb-2\\">Let\'s be honest...</h1>\\n<h2 className=\\"!m-0 text-gray-500\\">code reviews can sometimes be a <span className=\\"text-red-700\\">pain</span>.</h2>\\n\\nimport codeReviewWomanMan from \'../static/img/code-review-woman-man.jpeg\';\\n\\n<div className=\\"flex flex-col gap-1 max-w-sm mx-auto py-8\\">\\n  <img {...codeReviewWomanMan} alt=\\"engineers\\" />\\n  <span className=\\"text-gray-800 dark:text-gray-300\\">Photo by Desola Lanre-Ologun from{\' \'}\\n  <a href=\\"https://unsplash.com/photos/kwzWjTnDPLk\\"\\n    target=\\"_blank\\" rel=\\"noopener noreferrer\\"\\n  >Unsplash</a></span>\\n</div>\\n\\nAs the reviewer, you try to navigate through someone else\'s code, potentially in an unfamiliar codebase, as you strive to balance your inner perfectionist with \\"approving to unblock \ud83d\udc4d\\".\\n\\nOn the other side, as the PR author, you have to be vulnerable and expose your code to others for potential judgement. In simpler cases, you\'ll quickly make the requested changes and resolve comments. However, there are times when you might spend 15 minutes crafting a comprehensive response explaining your design choices, such as why you named a class `FooManager` instead of `FooStore`. Once after experiencing a review like this, a teammate of mine taught me about the term:\\n\\n> [bike shedding](https://en.wikipedia.org/wiki/Law_of_triviality) | Futile expenditure of time and energy in discussion of marginal technical issues.\\n\\nDespite these challenges, there\'s undoubtedly significant value in conducting code reviews, that\'s why we do them! Let\'s first discuss some of the goals of code reviews, and then see what kind of mindset we can build that will achieve these goals.\\n\\n### Knowledge Sharing\\n\\nKnowledge sharing should be a top priority in a healthy code review process. Ultimately, only one person can write any given line of code, but it\'s important that teammates and future engineers can understand the context of that code.\\n\\n#### As a PR author\\n\\nIt is your responsibility to make sure that your PR title and description are targeted towards your reviewers and any other engineers (including yourself) who might need to refer back to your PR in the future.\\n\\n:::tip\\nA reviewer shouldn\'t have to look at the code to understand what a PR is doing and why it is being done.\\n:::\\n\\nLet\'s take a look at an example PR that is refactoring date formatting logic into a shared `utils/date-format.ts` module.\\n\\n##### First, the PR title:\\n\\n> ## refactor: [JIRA-1234] Standardize date formatting in shared date-format module\\n\\nGiven this title, a reviewer immediately understands the following:\\n\\n1. The scope of this PR is limited to refactoring, so there is no need to look out for new features.\\n2. The Jira issue key enables them to quickly find **why** this work is being done.\\n3. A meaningful and searchable description of the changes that can be easily found at a later date.\\n\\n##### Next, the PR description:\\n\\n> Created `utils/date-format` which exposes functions for formatting dates in long and short formats. Found all places in the code that formatted Date objects, and updated them to use this new shared module. Any new code that does date formatting, should be using this shared module.\\n>\\n> Added `date-format.spec.ts` that tests the date formatting and handles edge cases like undefined dates.\\n\\nThis PR description is concise, focusing on educating the reviewer about the impact of the changes instead of explaining the code itself. Even if the reviewer didn\'t look at the code, they would know that this new module exists and that they should be using it in their own PRs.\\n\\n:::tip Mindset\\nI want to maximize the \\"knowledge gained\\" to \\"time\\" ratio for my reviewers.\\n\\n\\\\- **You**\\n:::\\n\\n:::caution Pitfalls to avoid\\n\\n- **Writing a PR title that is too vague** - A PR title should be a short but meaningful description of the changes in the PR. It should be searchable and immediately obvious to anyone who reads it what the PR\'s purpose is. For example, instead of writing \\"fix bug\\", write \\"fix: [JIRA-1234] handle undefined date in date formatting\\".\\n\\n- **Writing a PR description that explains the code** - This is a common mistake that I see in junior engineers. This is often a misuse of time, as reviewers will skip over your explanation of the code, and just jump to reading the actual code. Instead, focus on explaining the context of the changes in the PR description, and if necessary, explain the code in a PR comment, or even better, in a code comment.\\n\\n:::\\n\\n#### As a reviewer\\n\\nIt may sound obvious, but your task is straightforward: take the time to read the PR title and description. If the PR author followed the guidelines above, then you will gain a ton of useful knowledge by reading this content.\\n\\nIf the PR author did not provide a useful title/description, then you should ask them to! Ultimately, it will be much easier for the PR author to write this, then having each reviewer independently have to glean the same information by reading through all the code.\\n\\n:::tip Mindset\\nI want to understand the changes in this PR well enough so that I can make better decisions in the future.\\n\\n\\\\- **You**\\n:::\\n\\n:::caution Pitfalls to avoid\\n\\n- **Not giving feedback on a lacking PR title/description** - If you see a PR title/description that is lacking, then you should ask the author to improve it. This will save you time both now, as you won\'t have to spend time trying to understand the PR, and in the long run as it will encourage the author to write more informative PRs in the future.\\n\\n:::\\n\\n#### Overall\\n\\nIn order for any codebase to be effective in the long-term, it\'s important that overall understanding of the codebase be diffused amongst many engineers. It\'s too risky to have all the knowledge siloed into single engineers; using the mindsets above, you can work towards creating a culture of knowledge sharing.\\n\\n### Code Quality\\n\\nIt may be surprising, but code quality often comes second to knowledge sharing. It\'s essential first to ensure that your team communicates well, understanding what is trying to be accomplished and why it\'s important. Once that foundation is established, you can then focus on bringing your code up to the quality standard of the codebase.\\n\\n:::note\\nWe are not talking about code _correctness_ here; code correctness should be handled by testing and a QA process, but this is a topic for another article.\\n:::\\n\\n#### As a PR author\\n\\nOnce you have achieved the functionality that you desire, and you have communicated in your PR title/description the meaning of your changes, then you should focus on making your code as readable and maintainable as possible. These concepts will mean different things in different code bases, but here are some high-level guidelines that you can use.\\n\\n##### Standard patterns\\n\\nIf you are not solving a new _type_ of problem in your PR, then you should probably be adopting the common solution for that problem in your codebase. For instance, if you\'re working in a React codebase where Redux is used for state management throughout, it\'s best not to introduce a separate data store just for your own portion of the codebase. While it may seem like you\'re using \\"the best tool for the job\\", there is a long-term cost to introducing multiple ways of achieving the same thing in a codebase, ultimately making the codebase less readable and maintainable.\\n\\n##### Readable patterns\\n\\nIf you are writing code that will likely need to be adjusted and updated in the future (true in lots of situations), then focus on writing readable code over elegant or efficient code.\\n\\nBut what if you found a really cool way of doing a computation that is twice as fast but less readable? That\'s fine! Make sure you organize your code in such a way that the region of the code that is less readable won\'t need to be changed in the future. What do I mean?\\n\\nLet\'s say we have a function `doThing`\\n\\n```js\\nfunction doThing(args) {\\n  // simple data validation\\n\\n  // fetch from database\\n\\n  // ! do complex computation !\\n\\n  // write to database\\n\\n  return;\\n}\\n```\\n\\nThis function is achieving a lot, and our complex computation that we can optimize is right in the middle. If we were to be changing the database logic, then we would need to update this function, since the complex computation is in this function, the person updating the database logic would also have to read and understand the complex computation to make sure they didn\'t break it.\\n\\nTo resolve this, we can refactor `...do complex computation...` into the most stable minimal version.\\n\\n```js\\n/**\\n * Clear documentation on what this function\'s purpose is.\\n */\\nfunction doComplexComputation(args){\\n    ...do complex computation...\\n}\\n```\\n\\nIn this case, this function implementation won\'t need to be touched, and other parts of the code can depend on it. If the complex computation needs to be changed, then an engineer can still dive in and try to update the complex code, or they can just swap out the implementation with a new one without having to update other parts of the code. In either case, the complexity of the code is isolated to a single function, and the rest of the code is free to be written in a more readable way.\\n\\n##### Documentation\\n\\nAs much as possible, you should focus on first writing readable code, and if the code itself is not readable enough, then fall back on writing great documentation. Often, the most valuable documentation happens at the module level, answering questions like:\\n\\n1. What problem does this module solve?\\n2. When should I use this module?\\n3. What assumptions does this module make?\\n\\nGiven our `format-date` example above, we could write the following documentation:\\n\\n```js\\n/**\\n * This module contains functions to convert date objects into human-readable strings.\\n *\\n * Primarily intended for use in UI components, these functions should\\n * typically replace native `Date` object usage.\\n *\\n * They assume a user timezone is set in the global store; if not,\\n * the browser\'s timezone is used as a default.\\n */\\n```\\n\\n:::tip Mindset\\nI want to make other engineers think it is easier to read, understand, and maintain my code then replacing it with their own.\\n\\n\\\\- **You**\\n:::\\n\\n:::caution Pitfalls to avoid\\n\\n- **Partial refactors** - If you are introducing a new pattern into a codebase, if can be tempting to just use it in the new code you\'re writing in your PR, but this leads to the problem mentioned above where there are multiple ways of doing the same thing in the codebase. If you are introducing a new pattern, it has sufficient overlap with an existing pattern in the codebase, and it is **better** (by some objective metric) than the existing pattern, then you should refactor all of the existing code to use the new pattern as well.\\n\\n- **Never writing documentation** - Often times, engineers think that their own code is written so well, anyone glancing at it will immediately know what it does. This is not the case, often even yourself will forget the context of code only months later, so it\'s important to write documentation for the person who will be maintaining your code in the future and may have no context on the problem you were trying to solve.\\n\\n:::\\n\\n#### The Self Review\\n\\nThis PR habit has made a huge difference in the quality of my PRs. As soon as you think your PR is ready for sharing with others, take a pass through your own PR as if you were asked to review it.\\n\\n1. Read the PR title and description, make sure you can understand what is going on.\\n2. Go over each file and look for **obvious** mistakes or gaps in your code quality. If you can anticipate the majority of PR feedback, then you can save time for your reviewers and yourself to focus on high value feedback.\\n3. Make any changes from your self review (no need to actually leave PR comments), and commit the changes in a `refactor: self review` commit.\\n\\n:::tip Mindset\\nI want to get high quality feedback from my reviewers, so I\'m going to make sure there is no low-hanging fruit that I could identify myself.\\n\\n\\\\- **You**\\n:::\\n\\n:::caution Pitfalls to avoid\\n\\n- **Requesting a review too early** - If you request a review while your PR has a glaring issue that you could have spotted yourself, then you are not effectively using your reviewers\' time. You should be requesting a review when you are confident that your PR is ready for review, and you have already done a self review. If you want early feedback, you should be asking for feedback on your design or implementation plan, not a full review of your code.\\n\\n:::\\n\\n#### As a reviewer\\n\\nThis is where we are truly tested. It is easy to leave countless comments about how you would have implemented this differently, or how you don\'t like the style of the code. To make sure you provide the most value to the PR author and others, you should be categorizing your comments. Here are some examples:\\n\\n| Tag                                                       | Description                                                                                                                                                                                                |\\n| --------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\\n| `important: Do not use this deprecated method`            | These comments **must** be resolved before the PR should be merged.                                                                                                                                        |\\n| `style: Naming scheme`                                    | Style comments that are part of the codebase\'s explicitly agreed upon style guide or are undocumented standards within the codebase. This should **not** be subjective comments based on your preferences. |\\n| `question: How does this work?`                           | Non-blocking questions about the code, focusing on knowledge sharing.                                                                                                                                      |\\n| `recommend: Use built-in language feature that does this` | Recommendations that are not required but would likely bring meaningful improvements to the code.                                                                                                          |\\n| `nit: Use functional methods instead of procedural`       | Non-blocking subjective feedback.                                                                                                                                                                          |\\n| `supernit: Maybe call this function XYZ?`                 | Non-blocking subjective feedback, that you feel the need to comment on, but want to make it clear to the PR author that you\'re aware it is your personal preference and not very important.                |\\n\\nBy categorizing all of our feedback, we are setting up the PR author to make better decisions. If they have minimal time, then they should only focus on resolving the blocking feedback; if they have more time, then they can also go through the non-blocking comments and improve their PR even more.\\n\\nBy organizing our feedback into categories, we empower the PR author to make informed decisions. With limited time, they can prioritize addressing the blocking feedback; if they have spare time, then they can move on to address the non-blocking comments to improve their PR further.\\n\\n:::tip Mindset\\nMy goal is to communicate my unique perspective about this PR, while supporting the author in upholding quality benchmarks and completing their task.\\n\\n\\\\- **You**\\n:::\\n\\n:::caution Pitfalls to avoid\\n\\n- **Getting personal** - It is easy to get personal when reviewing code, especially if you feel like the PR author is not taking your feedback seriously. It is important to remember that the PR author is a human being, and they are trying their best (hopefully). If you feel like the PR conversations are getting heated, then it is time to take a step back, cool down, and reach out to the PR author to have a live code review (in-person or over video call) where you can communicate more effectively.\\n\\n:::\\n\\n### Conclusion\\n\\nCode reviews are an essential part of a software engineer\'s responsibilities, and they offer a unique challenge of mixing interpersonal, communication, and technical skills. In this article, we\'ve delved into the two main goals of PR reviews: \\"knowledge sharing\\" and \\"code quality.\\" The most important takeaways from this article should be the following mindsets:\\n\\n#### As a PR author\\n\\n:::tip Mindset\\nI want to maximize the \\"knowledge gained\\" to \\"time\\" ratio for my reviewers. By writing readable and maintainable code, I can ensure that future engineers will want to work with my code rather than replace it with their own.\\n\\n\\\\- **You**\\n:::\\n\\n#### As a reviewer\\n\\n:::tip Mindset\\nI want to fully grasp the changes in this PR, allowing me to provide my unique perspective during the review and make more informed decisions in the future. My ultimate goal is to enable the PR author to uphold quality standards and successfully deliver their code.\\n\\n\\\\- **You**\\n:::\\n\\nIf you can internalize these mindsets, then it will be much easier for you to adopt healthy PR habits and be a great teammate."},{"id":"first-blog-post","metadata":{"permalink":"/blog/first-blog-post","source":"@site/blog/2023-02-24-first-post.md","title":"First Blog Post","description":"This is my first blog post! You may think that this is a default post, but it is not. I wrote this post myself. I am a real person, living in the year 2023. I am writing this post to test the blog feature of the new version of the website. I hope you enjoy it!","date":"2023-02-24T00:00:00.000Z","formattedDate":"February 24, 2023","tags":[],"readingTime":0.335,"hasTruncateMarker":false,"authors":[{"name":"Eric Dudley","title":"Software Engineer","url":"https://www.linkedin.com/in/eric-dudley-894721106","imageURL":"https://github.com/ericdudley.png","key":"me"}],"frontMatter":{"slug":"first-blog-post","title":"First Blog Post","authors":"me","tags":[]},"prevItem":{"title":"Code Review Mindset","permalink":"/blog/code-review-mindset"}},"content":"This is my first blog post! You may think that this is a default post, but it is not. I wrote this post myself. I am a real person, living in the year 2023. I am writing this post to test the blog feature of the new version of the website. I hope you enjoy it!\\n\\nHere\'s to many more (actually helpful) blog posts in the future."}]}')}}]);